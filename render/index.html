<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ulogme</title>
    <link rel="icon" type="image/png" href="/favicon.png" />
    <link href='normalize.css' rel='stylesheet' type='text/css'>
    <link href='font_lato.css' rel='stylesheet' type='text/css'>
    <link href='font_teko.css' rel='stylesheet' type='text/css'>
    <link href='index_style.css' rel='stylesheet' type='text/css'>
    <link href='ion.rangeSlider.css' rel='stylesheet' type='text/css'>
    <link href='ion.rangeSlider.skinFlat.css' rel='stylesheet' type='text/css'>

    <script src="jquery-1.8.3.min.js"></script>
<!--     <script src="spin.min.js"></script> -->
    <script>
	window.onerror = ErrorLog;
	function ErrorLog (msg, url, line) {
	    if (url.includes("render_settings.js")) {
		alert("Error in render_settings.js: " + msg + "\nline: " + line);
		return true; // avoid to display an error message in the browser
	    }
	}
    </script>
    <script src="render_utils.js"></script>
    <script src="render_settings.js"></script>
    <script src="d3.min.js" charset="utf-8"></script>
    <script src="d3utils.js" charset="utf-8"></script>
    <script src="underscore.min.js" charset="utf-8"></script>
    <script src="ulogme_common.js" charset="utf-8"></script>
    <script src="highcharts.js"></script>
    <script src="exporting.js"></script>
    <script src="ion.rangeSlider.min.js" charset="utf-8"></script>
    <script src="mousetrap.min.js" charset="utf-8"></script>

    <link rel="stylesheet" href="spinner.css" type="text/css">
    <script type="text/javascript" src="spinner.js"></script>
    
    <script type="application/javascript">

    // GLOBALS
    var activity_color_hash = {}; // mapped titles -> hsl color to draw with
    var t00, t00_initial; // initial time for a day (time first event began)
    var ft, ft_initial; // final time for a day (time last event ended)
    var ecounts = {};
    var etypes = [];
    var hacking_stats = {};
    var spinner;
    var last_reload = 0;

    function visualizeTimeRangeSlider() {
    	var time_range_scale = function() {
            // This object represents time range scale in half hour increments,
            // starting at 7am and ending at 7:00am next day
    		var _values=[];
    		var _h = 7, _m = 0;
    		// Construct the scale array of string time representations
    		for (var _i=0; _i<=24*2; _i++) {
    			_values.push(("0"+_h).substr(-2)+":"+("0"+_m).substr(-2));
                _h = (_m==30) ? (_h < 23 ? _h+1 : 0) : _h;
                _m = (_m==0) ? 30 : 0;
    		}
    		return {
    			values: _values,
                // Get index on the scale
    			get_index: function (date, upper) {
    				// Optional overflow into next half-hour
    	            upper = (typeof upper === 'undefined') ? false : upper;
    	            var idx = date.getHours()*2 - 7*2 + Math.floor(date.getMinutes()/30+(upper ? 1 : 0));
    	            if (idx < 0) {
    	                idx += 24*2;
    	            } else if (idx == 0 && upper) {
                        idx += 24*2;
                    }
    	            return idx;
    	        },
    		}
    	}();
    	
    	var di = new Date(t00_initial * 1000)
        var from = time_range_scale.get_index(di);
        var df = new Date(ft_initial * 1000)
        var to = time_range_scale.get_index(df, true);
        var dow = di.getDay();
        var from_min = Math.min(
            from, 
            working_hours[dow].start ? time_range_scale.get_index(working_hours[dow].start) : from 
        );
        var from_max = Math.max(
            to, 
            working_hours[dow].end ? time_range_scale.get_index(working_hours[dow].end) : to 
        );
        var timerange_onchange_timer;
        
        $("#timerange_slider").ionRangeSlider({
    	    type: "double",
    	    grid: true,
    	    from: from,
    	    to: to,
    	    from_min: from_min,
    	    from_max: from_max,
    	    from_shadow: true,
            min_interval: 1,
            drag_interval: true,
    	    values: time_range_scale.values,
    	    onChange: function(data) {
    	    	clearTimeout(timerange_onchange_timer || 0);
    	    	timerange_onchange_timer = setTimeout(function () {
                    var d;
    	            d = new Date(t00_initial * 1000);
                    d.setHours(data.from_value.split(":")[0], data.from_value.split(":")[1], 0, 0);
    	    	    t00 = d.getTime() / 1000;
    	    	
                    d = new Date(ft_initial * 1000);
                    d.setHours(data.to_value.split(":")[0], data.to_value.split(":")[1], 0, 0);
                    ft = d.getTime() / 1000;

                    dirty = true;
    	    	    redraw();
    	            createPieChart(events, etypes, false);
    	    	}, 700);
    	    },
    	});
        // Save slider instance to var
        var slider = $("#timerange_slider").data("ionRangeSlider");
        
        var range_update_timer = setInterval(adjust_slider_from_max, get_time_to_next_update());

        function get_time_to_next_update() {
            var now = new Date();
            var remaining_time = 60*60 - (now.getMinutes()*60 + now.getSeconds()); 
        	return 1000*(remaining_time/60 <= 30 ? remaining_time : remaining_time-30*60);
        }
        
        function adjust_slider_from_max() {
            var d0 = new Date(t00_initial * 1000)
            // reset to 7am
            d0.setHours(7, 0, 0, 0);
            var now = new Date();
            if (now.getTime() >= d0.getTime()+24*60*60*1000) {
            	// Stop updating the slider to/from_max if time overrun over 7am next day
            	return
            }
            var to = time_range_scale.get_index(now, true);
            if (to <= slider.from) {
                to += 24*2;
            }
            slider.update({
                to:to,
            });
            clearInterval(range_update_timer);
            range_update_timer = setInterval(adjust_slider_from_max, get_time_to_next_update());
        }
    }
    
    
    // renders pie chart showing distribution of time spent into #piechart
	function createPieChart(es, etypes, animate) {
		animate = (typeof animate === 'undefined') ? true : animate;
		// count up the total amount of time spent in all windows
		var dtall = 0;
		//var counts = {};
		_.each(es, function(e) {
			if (e.t < t00 || e.t > ft) {
				return;
			}
			//counts[e.m] = (counts[e.m] || 0) + e.dt;
			dtall += e.dt;
		});

		/*
        var stats = _.map(etypes, function(m) {
			return {val: counts[m], 
				name: m + " (" + (100*counts[m]/dtall).toFixed(1) + "%)",
				col: activity_color_hash[m]
			};
		});
        */
		title = "Total Time: " + strTimeDelta(dtall);

		var colors = Highcharts.getOptions().colors,
			groupsData = [],
			activitiesData = [],
			i,
			j,
			brightness;

		// create color hash table, maps from window titles -> HSL color
		var activity_group_color_hash = colorHashStrings(_.uniq(_.pluck(activity_groups, 'name')));

		// Build the data array

		var title_to_group = {}
		for (var gi = 0; gi < activity_groups.length; gi += 1) {
			var ag = activity_groups[gi]
			for (var ti = 0; ti < ag.titles.length; ti += 1) {
				title_to_group[ag.titles[ti]] = ag
			}
		}
		var data_tree = {},
			ev,
			ag,
			d;
		for (i = 0; i < es.length; i += 1) {
			ev = es[i]
            if (ev.t < t00 || ev.t > ft) {
                continue;
            }
			ag = title_to_group[ev.m]
			if (ag.name in data_tree) {
				data_tree[ag.name].total = data_tree[ag.name].total + ev.dt
				data_tree[ag.name].activities[ev.m] = (data_tree[ag.name].activities[ev.m] || 0) + ev.dt
			} else {
				data_tree[ag.name] = {
					name: ag.name,
					plevel: ag.plevel,
					color: (ag.color || null),
					total: ev.dt,
					activities: {}
				}
				data_tree[ag.name].activities[ev.m] = ev.dt
			}
		}

		var productivity_pulse = 0;
		for (var agi = 0; agi < activity_groups.length; agi += 1) {
			if (!(activity_groups[agi].name in data_tree)) {
			    continue;	
			}
            ag = data_tree[activity_groups[agi].name];
			groupsData.push({
				name: ag.name,
				y: ag.total,
				color: ag.color || activity_group_color_hash[ag.name],
				dataLabels: {
					rotation:0,
				},
			});
			productivity_pulse = productivity_pulse + (ag.plevel / dtall * ag.total);  
			var activity_names = Object.keys(ag.activities).sort(function(a,b){
				var cmp = a.toLowerCase().localeCompare(b.toLowerCase())
				return cmp != 0 ? cmp : a.localeCompare(b);
			});
	        var an;
			for (i = 0; i < activity_names.length; i += 1) {
				an = activity_names[i];
				activitiesData.push({
					name: an,
					y: ag.activities[an],
					color: activity_color_hash[an],
				});
			}
		}
        var dow = new Date(t00_initial * 1000).getDay();
        var today_workable_hours = working_hours[dow].start && working_hours[dow].end ? 
            (working_hours[dow].end.getTime() - working_hours[dow].start.getTime())/1000/60/60 
            : 0;
        if (today_workable_hours > 0) {
        	// Handicap for not working all workable hours
        	if (dtall/60/60 < today_workable_hours) {
                productivity_pulse = productivity_pulse / (today_workable_hours / (dtall/60/60));
        	}
        }
		productivity_pulse = Math.round(productivity_pulse);
		
        var previous_productivity_pulse = null
            ,productivity_gain = 0;
        var d0 = new Date(t00 * 1000)
        // reset to 7am
        d0.setHours(7, 0, 0, 0);
        var today_s = d0.getTime() / 1000;
        setCookie("ulogme-productivity-pulse-" + today_s, productivity_pulse, 30);
        var days = 1;
		while (true) {
			   var previous_day = new Date((today_s - days*24*60*60)*1000);
			   previous_productivity_pulse = getCookie("ulogme-productivity-pulse-" + previous_day.getTime()/1000) || null;
               // Successfully got previous day pulse
			   if (previous_productivity_pulse > 0) {
            	   break;
               } 
               // Previous day pulse was 0, return it only if it was not a weekend
			   else if (previous_productivity_pulse == 0) {
            	   if (!skip_zero_weekend_pulse) {
            		   break
            	   }
                   // Return only if not weekend
            	   if (previous_day.getDay() != 0 && previous_day.getDay() != 6) {
            		   break;
            	   }
               }
               // Give up after checking 10 days
               if (days == 10) {
            	   break;
               }
               days++;
		}
        productivity_gain = previous_productivity_pulse != null ? productivity_pulse - previous_productivity_pulse : 0;  

	    // Create the chart
        var main_chart_options = {
            credits: {
                  enabled: false
            },
            chart: {
                plotBackgroundColor: null,
                plotBorderWidth: null,
                type: 'pie'
            },
            title: {
                text: 'Activity breakdown',
                style: {
                    'padding-bottom': '15px'
                }
            },
            subtitle: {
                text: 'Total time: ' + strTimeDelta(dtall, false),
                style: {
                    fontWeight: 'bold',
                    fontSize: '18pt',
                }
            },
            plotOptions: {
                pie: {
                    shadow: false,
                    center: ['50%', '45%'],
                    allowPointSelect: true,
                    showInLegend: true,
                },
            },
            tooltip: {
                valueSuffix: '%',
                formatter: function () {
                    return strTimeDelta(this.y, false) + ' (' + this.percentage.toFixed(1) + '%)';
                }
            },
            series: [{
                name: 'Work balance',
                data: groupsData,
                size: '40%',
                innerSize: '70%',
                dataLabels: {
                    formatter: function () {
                        return this.y >= 0 ? this.point.name.toUpperCase().substring(0,3)/* + ' (' + strTimeDelta(this.y, false) + ")"*/ : null;
                    },
                    color: '#000000',
                    style: {
                        fontSize: '8pt',
                    },
                    distance: -55,
                    rotation: 0,
                },
                allowPointSelect: false,
                showInLegend: false,
                animation: animate ? {
                    duration: 400,
                } : false,
            }, {
                name: 'Activities',
                data: activitiesData,
                size: '70%',
                innerSize: '65%',
                dataLabels: {
                    formatter: function () {
                        // display only if larger than 1
                        return this.y > 1 ? '<b>' + this.point.name + '</b>: ' +  strTimeDelta(this.y, false)
                        	    : null;
                    },
                    style: {
                        fontSize: '10pt',
                        'font-family': "'Teko', sans-serif",
                    },
                },
                animation: animate ? {
                    duration: 600,
                } : false,
            }]
        };
      
        var allY, angle1, angle2, angle3;
        var rotate = function () {
            var p = main_chart_options.series[0];
            angle1 = 0;
            angle2 = 0;
            angle3 = 0;
            allY = 0;
            $.each(p.data, function (i, p) {
                allY += p.y;
            });
    
            $.each(p.data, function (i, p) {
                angle2 = angle1 + p.y * 360 / (allY);
                angle3 = angle2 - p.y * 360 / (2 * allY);
                if(angle3>=180){
                p.dataLabels.rotation = angle3;
                }else{
                p.dataLabels.rotation = angle3;
                }
                angle1 = angle2;
            });
        };

        //rotate();
        $('#piechart').highcharts(main_chart_options);

        //productivity_gain = 95;
		var tl_chart_options = {
			credits: {
				enabled: false
			},
			exporting: {
				enabled: false,
			},
        chart: {
                plotBackgroundColor: null,
                plotBorderWidth: null,
            type: 'pie', 
            backgroundColor: null, //'rgba(192, 192, 192, 0.002)',
        },
        title: {
            text: '<div style="border:0px solid red;position:absolute;top:-50px;left:-40px;text-align:center;">'
                + '<span style="height:70px;font-size:70px !important; font-family : \'Teko\', sans-serif;display: inline-block !important;">' + Math.round(productivity_pulse) + '</span>'
                 +'<span style="font-size:18px !important; font-family : \'Teko\', sans-serif;"> ' +(productivity_gain != 0 ? 
                         ' '+(productivity_gain > 0 ? '<span style="color:#005b96;font-weight:600;">&#x2b06;' + productivity_gain + '</span>'
                                 : '<span style="color:red;font-weight:600;">&#x2b07;' + Math.abs(productivity_gain) + '</span>'
                                 )
                      : ' <strong>---</strong>')//'/100
                      +'</span>'
                 +'<br><span style="font-size:15px;">' + PRODUCTIVITY_PULSE_NAME.split(" ")[0]
                 /*
                 + (productivity_gain != 0 ? 
                	' '+(productivity_gain > 0 ? '<span style="color:#005b96;font-weight:600;">&#x2b06;' + productivity_gain + '</span>'
                			   : '<span style="color:red;font-weight:600;">&#x2b07;' + Math.abs(productivity_gain) + '</span>'
                			   )
                	: ' <strong>---</strong>')
                */
                 +'</span>'
                 +'</div>',
            useHTML: true,
            verticalAlign: 'middle',
        },
        plotOptions: {
            pie: {
                shadow: false,
                center: ['50%', '50%'],
		allowPointSelect: true,
		showInLegend: true,
                startAngle: -150,
                endAngle: 80,
                colors: function () {
                    var colors = [],
                        base = Highcharts.getOptions().colors[0],
                        i;

                    for (i = 0; i < 10; i += 1) {
                        // Start out with a darkened base color (negative brighten), and end
                        // up with a much brighter color
                        colors.push(Highcharts.Color(base).brighten((i - 3) / 7).get());
                    }
                    return colors;
                },
	    },
        },
        tooltip: {
            valueSuffix: '',
            formatter: function () {
            	var a = data_tree[this.point.name];
            	var tt = PL_NAMES[data_tree[this.point.name].plevel];
            	return tt;
                //return strTimeDelta(this.y, false) + ' (' + this.percentage.toFixed(1) + '%)';
            }
        },
        series: [{
            name: 'Productivity',
            data: groupsData,
            size: '100%',
	        innerSize: '75%',
            dataLabels: {
                formatter: function () {
                    return null; //this.y >= 0 ? this.point.name.toUpperCase() + '<br>' + strTimeDelta(this.y, false) + ""  : null;
                },
                color: '#000000',
                style: {
                    fontSize: '10pt',
                },
                distance: 20,
                rotation: 0,
            },
            //allowPointSelect: false,
            showInLegend: false,
            animation: animate ? {
                duration: 1200,
            } : false,
        }],
      };

      $('#piechart_tl').highcharts(tl_chart_options);
    }


    // creates the main barcode time visualization for all mapped window titles
    function visualizeEvents(es) {
      $("#eventvis").empty();
      _.each(display_groups, function(x) { visualizeEvent(es, x); })
    }

    // uses global variable hacking_events as input. Must be set
    // and global total_hacking_time as well.
    function visualizeHackingTimes(hacking_stats) {
      $("#hackingvis").empty();
      if(!draw_hacking) {
          return; // global set in render_settings.js
      }
      var c = "rgb(200,0,0)"; // color

      var div = d3.select("#hackingvis").append("div");
      div.append("p").attr("class", "tt").attr("style", "color:"+c).text(hacking_title);
      var txt = strTimeDelta(hacking_stats.total_hacking_time);
      txt += " (total keys = " + hacking_stats.total_hacking_keys + ")";
      div.append("p").attr("class", "td").text(txt);

      var hacking_titles_div = div.append("div").attr("class", "fsdiv");
      for (var q=0; q < hacking_titles.length; q++) {
        hacking_titles_div = hacking_titles_div.append("div").attr("class", "fdiv").attr("style", "margin-right: 0px;");
        hacking_titles_div.append("span").attr("class", "tt").attr("style", "font-size: 10pt; font-weight:bold; color: black"
	// + activity_color_hash[hacking_titles[q]]
	).text(hacking_titles[q]);
      }

      var W = $(window).width() - 40;
      var svg = div.append("svg")
      .attr("width", W)
      .attr("height", 30);

      var sx = (ft-t00) / W;
      var g = svg.selectAll(".h")
        .data(hacking_stats.events)
        .enter().append("g")
        .attr("class", "h")
        .on("mouseover", function(d){return tooltip.style("visibility", "visible").text(strTimeDelta(d.dt));})
        .on("mousemove", function(){return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");})
        .on("mouseout", function(){return tooltip.style("visibility", "hidden");});

      g.append("rect")
        .attr("x", function(d) { return (d.t0-t00)/sx; } )
        .attr("width", function(d) { return d.dt/sx; } )
        .attr("y", function(d) {return 30-10*d.intensity} )
        .attr("height", function(d) {return 10*d.intensity; })
        .attr("fill", function(d) { return c; });
    }

    // number of keys pressed in every window type visualization
    function visualizeKeyStats(key_stats, etypes) {
      $("#keystats").empty();

      // format input for d3
      var stats = _.map(etypes, function(m) { 
        return {
          name: m,
          val: key_stats.hasOwnProperty(m) ? key_stats[m].f : 0,
          col: activity_color_hash[m],
        };
      });
      stats = _.filter(stats, function(d) { return d.val > 60 }); // cutoff at 1 minute
      _.each(stats, function(d) { 
        var fn = (d.val / (key_stats[d.name].n * 9.0)).toFixed(2); 
        d.text = d.val + ' (' + fn + '/s) ' + d.name;
      });
      stats = _.sortBy(stats, 'val').reverse();

      // visualize as horizontal bars with d3
      var chart_data = {};
      chart_data.width = 700;
      chart_data.barheight = 30;
      chart_data.textpad = 300;
      chart_data.textmargin = 10;
      chart_data.title = "Total number of key strokes";
      chart_data.data = stats;
      d3utils.drawHorizontalBarChart(d3.select('#keystats'), chart_data);
    }

    // simple plot of key frequencies over time
    function visualizeKeyFreq(es) {
      $("#keygraph").empty();

      var W = $(window).width() - 40;

      var div = d3.select("#keygraph").append("div");
      var svg = div.append("svg")
      .attr("width", "100%")
      .attr("height", 100);

      var sx = (ft-t00) / W;
      var line = d3.svg.line()
        .x(function(d) { return (d.t -t00) / sx; })
        .y(function(d) { return 100 - d.s; });

      svg.append("path")
        .datum(es)
        .attr("class", "line")
        .attr("d", line);

      div.append("p").attr("class", "al").text("keystroke frequency");
    }

    function visualizeNotes(es) {
      console.log('number of notes:' + es.length);
      $("#notesvis").empty();
      if(!draw_notes) return; // draw_notes is set in render_settings.js
      if(es.length === 0) return; // nothing to do here...

      var coffees = [];
      var dts= [];
      for(var i=0,N=es.length;i<N;i++) {
        var e = es[i];
        var d = {};
        d.x = e.t-t00;
        d.s = e.s;
        if (e.s.toLowerCase().indexOf("coffee") > -1) {
          // we had coffee
          coffees.push(e.t-t00);
        }
        dts.push(d);
      }

      console.log('drawing ' + dts.length + ' notes.');
      var div = d3.select("#notesvis").append("div");
      div.append("p").attr("class", "tt").attr("style", "color: #964B00").text("Notes");
      var W = $(window).width() - 40;
      var svg = div.append("svg")
      .attr("width", W)
      .attr("height", 70);

      var sx = (ft-t00) / W;

      // Draw coffee. Overlay
      // draw_coffee is set in render_settings.js
      if(draw_coffee) {
        var coffex = [];
        var nc = coffees.length;
        var alpha = Math.log(2)/20520; // 20,520 is half life of coffee, in seconds. Roughly 6 hours
        for(var i=0;i<100;i++) {
          there = i*(ft-t00)/100.0;
          // coffee is assumed to add linearly in the body
          var amount = 0;
          for(var j=0;j<nc;j++) {
            if(there > coffees[j]) {
              amount += Math.exp(-alpha*(there - coffees[j]));
            }
          }
          coffex.push({t:there, a:30*amount}); // scale is roughly 30px = 150mg coffee, for now
        }
        var cdx = (ft - t00)/100.0;
        var g = svg.selectAll(".c")
          .data(coffex)
          .enter()
          .append("rect")
          .attr("width", cdx/sx)
          .attr("x", function(d){ return d.t/sx; })
          .attr("y", function(d){ return 50-d.a; })
          .attr("height", function(d){ return d.a; })
          .attr("fill", "#E4CFBA");
      }

      // draw notes
      var g = svg.selectAll(".n")
        .data(dts)
        .enter().append("g")
        .attr("class", "n");

      g.append("rect")
        .attr("x", function(d) { return d.x/sx; } )
        .attr("width", 2)
        .attr("y", 0)
        .attr("height", 50)
        .attr("fill", "#964B00");

      g.append("text")
        .attr("transform", function(d,i) { return "translate(" + (d.x/sx+5) + "," + (10+15*(i%5)) + ")"; })
        .attr("font-family", "'Lato', sans-serif")
        .attr("font-size", 14)
        .attr("fill", "#333")
        .text(function(d) { return d.s; } );
    }

    var clicktime;
    function visualizeEvent(es, filter) {

      var dts = [];
      var ttot = 0;
      var ttoti = [];
      var filter_colors = [];
      for(var q=0;q<filter.length;q++) { 
        filter_colors[q] = activity_color_hash[filter[q]];
        ttoti.push(0); 
      }
      for(var i=0,N=es.length;i<N;i++) {
        var e = es[i];
        var fix = filter.indexOf(e.m);
        if( fix === -1) { continue; }
        ttot += e.dt;
        ttoti[fix] += e.dt;
        if(e.dt < 10) continue; // less than few second event? skip drawing. Not a concentrated activity
        var d = {};
        d.x = e.t - t00;
        d.w = e.dt;
        if (e.s.indexOf("|") != -1) {
			// Split the record and get just the window title (part after first |)
            title = e.s.split(/\|(.*)/)[1]
        } else {
            title = e.s
        } 
        d.s = title + " (" + strTimeDelta(e.dt) + ")";
        d.fix = fix;
        dts.push(d);
      }
      if(ttot < 60) return; // less than a minute of activity? skip

      console.log('drawing filter ' + filter + ' with ' + dts.length + ' events.');

      var div = d3.select("#eventvis").append("div");

      var filters_div = div.append("div").attr("class", "fsdiv");
      for(var q=0;q<filter.length;q++) {
        if(ttoti[q] === 0) continue; // this filter wasnt found

        var filter_div = filters_div.append("div").attr("class", "fdiv");
        var c = filter_colors[q];
        filter_div.append("p").attr("class", "tt").attr("style", "color:"+c).text(filter[q]);
        var txt = strTimeDelta(ttoti[q]);
        filter_div.append("p").attr("class", "td").text(txt);
      }

      var W = $(window).width() - 40;
      var svg = div.append("svg")
      .attr("width", W)
      .attr("height", 70);

      var sx = (ft-t00) / W;
      var g = svg.selectAll(".e")
        .data(dts)
        .enter().append("g")
        .attr("class", "e")
        .on("mouseover", function(d){return tooltip.style("visibility", "visible").text(d.s);})
        .on("mousemove", function(){return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");})
        .on("mouseout", function(){return tooltip.style("visibility", "hidden");})
        .on("click", function(d){ 
          $("#notesinfo").show(); 
          $("#notesmsg").html("clicked event <b>" + d.s + "</b><br> Add note at time of this event:");
          $("#notetext").focus()
          clicktime = d.x+t00;
          return 0; 
          });

      g.append("rect")
        .attr("x", function(d) { return d.x/sx; } )
        .attr("width", function(d) { return d.w/sx; } )
        .attr("y", 0)
        .attr("height", 50)
        .attr("fill", function(d) { return filter_colors[d.fix]; });

      // produce little axis numbers along the timeline
      var d0 = new Date(t00 * 1000);
      d0.setMinutes(0);
      d0.setSeconds(0);
      d0.setMilliseconds(0);
      var t = d0.getTime() / 1000; // cropped hour
      while(t < ft) {
        svg.append("text")
          .attr("transform", "translate(" + [(t-t00)/sx, 70] + ")")
          .attr("font-family", "'Lato', sans-serif")
          .attr("font-size", 14)
          .attr("fill", "#CCC")
          .text(new Date(t * 1000).getHours());
        t += 3600;
      }
    }

    // count up how much every event took
    function statEvents(es) {
      if(es.length === 0) return;

      var t0 = es[0].t;
      var ixprev = 0;
      for(var i=1,N=es.length;i<N;i++) {
        var e = es[i];
        var dt = es[i].t - es[ixprev].t; // length of time for last event
        es[ixprev].dt = dt;
        var tmap = es[ixprev].m; // mapped title of previous events
        if(ecounts.hasOwnProperty(tmap)) {
          ecounts[tmap] += dt;
        } else {
          ecounts[tmap] = 0;
          etypes.push(tmap); // catalogue these in a list
        }
        ixprev = i;
      }
      es[N-1].dt = 1; // last event we dont know how long lasted. assume 1 second?
    }

    function writeHeader() {
      var date0 = new Date(t00*1000);
      var date1 = new Date(ft*1000);
      $("#header").html('<h2>' + ppDate(date0) + ' - ' + ppDate(date1) + '</h2>');
    }

    function startSpinner() {
      // create a spinner
      //opts = { left:'50px', top:'40px', radius: 10, color: "#FFF", lines:15, length:9 };
      //var spinner = new Spinner(opts).spin(target);
      if (typeof spinner === "undefined") {
    	  spinner = new Spinner(
    		document.getElementById('spinnerdiv'), 
    		{
    	      color: 'white',
    	      y: '80%',
    	      x: '80%',
    	      showCurtain: false,
    	    });
          spinner.start();
      } else {
          spinner.show();
      }
    }
    function stopSpinner() {
      //$("#spinnerdiv").empty();
        setTimeout(function() { spinner.hide() }, 500);
    }

    function renderBlogEntry(blog) {
        if (blog === '') {
            $("#blogpre").attr("class", "empty").text('Click to enter the note for this day');
            $("#blogstash").text('');
        } else {
            $("#blogpre").attr("class", "notempty").text(blog);
            $("#blogstash").text(blog);
        }
    }

    function fetchAndLoadEvents(daylog, animate) {
      animate = (typeof animate === 'undefined') ? true : animate;
      loaded = false;
      // we do this random thing to defeat caching. Very annoying
      var json_path = daylog.fname + "?sigh=" + Math.floor(10000*Math.random());

      // fill in blog area with blog for this day
      $.getJSON(json_path, function(data){
        loaded = true;

        // save these as globals for later access
        events = data['window_events'];
        key_events = data['keyfreq_events']
        notes_events = data['notes_events']

        // map all window titles through the (customizable) mapwin function
        _.each(events, function(e) { e.m = mapwin(e.s); });
        
        // compute various statistics
        statEvents(events);

        // create color hash table, maps from window titles -> HSL color
        activity_color_hash = colorHashStrings(_.uniq(_.pluck(events, 'm')));

        // find the time extent: min and max time for this day
        if(events.length > 0) {
          t00 = _.min(_.pluck(events, 't'));
          ft = _.max(_.map(events, function(e) { return e.t + e.dt; }))
        } else {
          t00 = daylog.t0;
          ft = daylog.t1;
        }
        t00_initial = t00;
        ft_initial = ft;

        renderBlogEntry('blog' in data ? data['blog'] : '');

        visualizeEvents(events);
        writeHeader();
        visualizeTimeRangeSlider();
        createPieChart(events, etypes, animate);
        computeKeyStats(events, key_events);
        hacking_stats = computeHackingStats(events, key_events, hacking_titles);
        visualizeHackingTimes(hacking_stats);
        key_stats = computeKeyStats(events, key_events);
        visualizeKeyStats(key_stats, etypes);
        visualizeKeyFreq(key_events);
        visualizeNotes(notes_events);
      });
    }

    var events;
    var key_events;
    var notes_events;
    var blog;
    var tooltip;
    var event_list = [];
    var loaded = false;
    var cur_event_id = -1;
    var clicktime = 0;
    function start() {
      
      // create tooltip div
      tooltip = d3.select("body")
      .append("div")
      .style("position", "absolute")
      .style("z-index", "10")
      .style("visibility", "hidden")
      .text("");

      // we do this random thing to defeat caching. Very annoying
      $.getJSON("export_list.json?sigh=" + Math.floor(10000*Math.random()), function(data){
        event_list = data; // assign to global variable

        cur_event_id = event_list.length - 1;
        if('gotoday' in QueryString) { cur_event_id = parseInt(QueryString.gotoday); }

        fetchAndLoadEvents(event_list[cur_event_id]); // display latest
      });

      // setup notes hide key
      $("#notesinfohide").click(function(){ $("#notesinfo").hide(); });

      // setup refresh handler to create a post request to /reload
      $("#reloadbutton").click(reload);

      // set up notes add handler
      $("#notesadd").click(function() {

        startSpinner();
        $.post("/addnote",
          {"note": $("#notetext").val(), "time": clicktime},
          function(data,status){
            console.log("Data: " + data + "\nStatus: " + status);
            if(data === 'OK') {
              // everything went well, refresh current view
              $("#notetext").val('') // erase
              $("#notesinfo").hide(); // take away
              fetchAndLoadEvents(event_list[cur_event_id]);
            }
            //stopSpinner();
        });
      });

      // register enter key in notes as submitting
      $("#notetext").keyup(function(event){
        if(event.keyCode == 13){
          $("#notesadd").click();
        }
      });

      // setup arrow events
      $("#leftarrow").click(function() {
        cur_event_id--;
        if(cur_event_id < 0) {
          cur_event_id = 0;
        } else {
          fetchAndLoadEvents(event_list[cur_event_id]); // display latest
          $("#notesinfo").hide();
          $("#blogenter").hide();
          $("#blogpre").show();
        }
      });
      $("#rightarrow").click(function() {
        cur_event_id++;
        if(cur_event_id >= event_list.length) {
          cur_event_id = event_list.length - 1;
        } else {
          fetchAndLoadEvents(event_list[cur_event_id]); // display latest
          $("#notesinfo").hide();
          $("#blogenter").hide();
          $("#blogpre").show();
        }
      });

      // setup blog text click event
      $("#blogenter").hide();
      $("#blogpre").click(function(event){
        var txt = $("#blogstash").text();
        $("#blogpre").hide();
        $("#blogenter").show();
        $("#blogentertxt").val(txt)
        $("#blogentertxt").focus();
        Mousetrap.bind('esc', function() {
            renderBlogEntry($("#blogentertxt").val());
            $("#blogpre").show();
            $("#blogenter").hide();
            Mousetrap.unbind("esc");
            Mousetrap.unbind("mod+enter");
         });
        Mousetrap.bind('mod+enter', function() {
        	$("#blogentersubmit").trigger("click");
         });
        event.stopPropagation();
      });

      // setup the submit blog entry button
      $("#blogentersubmit").click(function(){
          Mousetrap.unbind("esc");
          Mousetrap.unbind("mod+enter");

        var txt = $("#blogentertxt").val();
        renderBlogEntry(txt);
        $("#blogpre").show();
        $("#blogenter").hide();
        
        // submit to server with POST request
        $.post("/blog",
          {"time" : event_list[cur_event_id].t0, "post": txt},
           function(data,status){
            console.log("Data: " + data + "\nStatus: " + status);
            if(data === 'OK') {
              // everything went well
            }
            stopSpinner();
          });
      });

      $(document).click(function(event) {
          if(!$(event.target).closest('#blogenter').length) {
              if ($('#blogenter').is(":visible")) {
                  renderBlogEntry($("#blogentertxt").val());
                  $("#blogpre").show();
                  $("#blogenter").hide();
                  Mousetrap.unbind("esc");
                  Mousetrap.unbind("mod+enter");
              }
          }
      })

      setInterval(redraw, 1000); // in case of window resize, we can redraw
      if (auto_reload_interval > 0) {
		setInterval(auto_reload, auto_reload_interval*60*1000);
      }

      Mousetrap.bind('r', function() {
       	 if (Date.now() - last_reload < 1000) {
       		 return;
         }
	     reload();
         last_reload = Date.now();
      });
      
      Mousetrap.bind('n', function() {
    	  $('#blogpre').trigger("click");
      }, 'keyup');
      
      // Save original stopCallback function
      Mousetrap_stopCallback = Mousetrap.prototype.stopCallback;
      // Override stopCallback function to allow handling of Esc/Command+Enter hotkeys in blogentry
      Mousetrap.prototype.stopCallback = function(e, element, combo) {
          if (element.id == "blogentertxt" && (combo == "esc" || combo == "mod+enter")) {
              return false;
          } else {
              return Mousetrap_stopCallback(e, element, combo);
          }
      }      
    }

    function reload(animate) {
        animate = (typeof animate === 'undefined') ? true : animate;
        startSpinner();
        var r_time = 0;
        if (cur_event_id >= 0 && event_list) {
            r_time = event_list[cur_event_id].t0;
        }
        $.post("/refresh",
          {"time" : r_time},
          function(data,status){
            console.log("Data: " + data + "\nStatus: " + status);
            if(data === 'OK') {
              // everything went well, refresh current view
              fetchAndLoadEvents(event_list[cur_event_id], animate);
            }
            stopSpinner();
        });
    }

    function auto_reload() {
      reload(false);
    }

    // redraw if dirty (due to window resize event)
    function redraw() {
      if(!dirty) return;
      if(!loaded) return;
      visualizeEvents(events);
      visualizeKeyFreq(key_events);
      visualizeNotes(notes_events);
      visualizeHackingTimes(hacking_stats);
      dirty = false;
    }

    var dirty = false;
    $(window).resize(function() {
      dirty = true;
    });

    </script>
  </head>
  <body onload="start()">
    <div id="spinnerdiv"></div>
    <div id="reloadbutton"></div>
    <div id="overviewlink"><a href="overview.html">Overview</a></div>
    <h1>ulogme</h1>
    <div class="arrow">
      <span class="helper"></span><img id="leftarrow" src="double-chevron-left.svg" height=40 />
      <div id="header"></div>
      <span class="helper"></span><img id="rightarrow" src="double-chevron-right.svg" height=40 />
    </div>
    <div id="time-range" value="">
        <div style="position:absolute; z-index:-1; left:600px; height:20px; width: 800px; background-color: #ccc;"></div>
        <input type="text" id="timerange_slider" name="timerange_slider" value="" style="display:none;"/>
    </div>
    <div id="wrap">
      <div id="piecharts">
          <div id="piechart_tl"></div>
          <div id="piechart_tl_centertext" style="position:absolute; left:0px; top:0px;"></div>
          <div id="piechart"></div>
          <div id="piechart_tl_centertext" style="position:absolute; left:0px; top:0px;"></div>
      </div>
      <div id="blogwrap">
        <div id="blogstash" style="display:none"></div>
        <pre id="blogpre" class="empty"></pre>
        <div id="blogenter">
          <textarea id="blogentertxt" placeholder="Enter the note for this day"></textarea>
          <button id="blogentersubmit">Submit</button>
        </div>
      </div>
      <div id="keystats"></div>
      <div id="keygraph"></div>
      <div id="notesinfo">
        <div id="notesinfohide">X</div>
        <div>
          <div id="notesmsg"></div>
          <input type="text" id="notetext">
          <div id="notesadd">Add</div>
        </div>
      </div>
      <div id="notesvis"></div>
      <div id="hackingvis"></div>
      <div id="eventvis"></div>
    </div>
  </body>
</html>
